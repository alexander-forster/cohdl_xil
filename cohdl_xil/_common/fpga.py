from __future__ import annotations
from dataclasses import dataclass

import enum

import cohdl
from pathlib import Path
from cohdl import Port

from .tcl_writer import TclWriter
from .io_standards import IoStandard
from .vivado_project import VivadoProject, Project, set_active_project
from .constraints import Constraints, Clock
from cohdl.utility import MakeTarget

Direction = cohdl.Port.Direction

# build/
#   Makefile
#   generated/          > contains all files generated by CoHDL (except Makefile)
#       project.tcl
#       constraints/
#           ...
#       vhdl/
#           ...
#       ip_scripts/
#           ...
#   output/             > running make only changes files in this directory
#       ip/
#           ip_module_name/
#               ip_module_name.xci
#               ...
#       reports/
#           a.rpt
#           b.rpt
#       synthesis/
#           ???
#       implementation/
#           project.bit
#
#


@dataclass
class PortCapability:
    ident: str
    supported_directions: list[Direction]
    supported_io: list[IoStandard]

    def check_configuration(self, config: PortConfiguration):
        assert config.ident == self.ident
        assert config.direction in self.supported_directions
        assert config.io_standard in self.supported_io


@dataclass
class PortConfiguration:
    ident: str
    direction: Direction
    io_standard: IoStandard


class FpgaPorts:
    def __init__(self, port_capability_list: list[PortCapability]):
        self.ports = {port.ident: port for port in port_capability_list}

    def check_config(self, config: PortConfiguration):
        self.ports[config.ident].check_configuration(config)

    def check_usage(self, ident: str, direction: Direction, io_standard: IoStandard):
        config = PortConfiguration(ident, direction, io_standard)
        self.check_config(config)


class Fpga:
    ports: FpgaPorts

    def __init__(self, build_dir, part_id, top_entity: str = "TopEntity"):
        self.part_id = part_id
        self.build_dir = build_dir
        self._top_entity_name = top_entity
        self._arch = None

        self._contraints = Constraints()

        self._used_ports: dict[str, cohdl.Port] = {}

        self._top_entity: cohdl.Entity | None = None

    def _set_architecture(self, architecture):
        self._arch = architecture

    def architecture(self, fn):
        self._arch = fn

    def configure_port(
        self, port: Port, config: PortConfiguration | list[PortConfiguration]
    ):
        name = port.name()

        if issubclass(port.type, cohdl.Bit):
            assert port.direction() is config.direction
            assert isinstance(config, PortConfiguration)
            assert name not in self._used_ports
            self.ports.check_config(config)

            self._contraints.add_constrained_port(
                name, config.ident, str(config.io_standard)
            )
        elif issubclass(port.type, cohdl.BitVector):
            width = port.width

            assert isinstance(config, list) and width == len(config)

            for nr, c in enumerate(config):
                assert c.direction is port.direction()
                self.ports.check_config(c)

                self._contraints.add_constrained_port(
                    f"{name}[{nr}]", c.ident, str(c.io_standard)
                )
        else:
            raise AssertionError(f"invalid port type {port.type}")

        self._used_ports[name] = port
        self._top_entity._info.add_port(name, port)

    def reserve_port(
        self, name, port_type, config: PortConfiguration | list[PortConfiguration]
    ):
        if isinstance(config, PortConfiguration):
            direction = config.direction
        else:
            direction = config[0].direction

        port = Port[port_type, direction](name=name)

        self.configure_port(port, config)

        return port

    def define_clock(
        self, port: Port, period_ns: float | None = None, freq: int | None = None
    ):
        assert issubclass(port.type, cohdl.Bit)
        constrained = self._contraints.get_constrained(port.name())

        constrained.set_clock(Clock("MY_CLOCK_NAME", period_ns, (0, 5)))

    def reserve_clock(self, name, config: PortConfiguration, period_ns: float):
        assert config.direction is Direction.INPUT
        port = self.reserve_port(name, cohdl.Bit, config)

        self.define_clock(port, period_ns=period_ns)

        freq = int(1 / period_ns * 1_000_000_000)
        return cohdl.std.Clock(port, frequency=freq)

    def build(self, *, build_dir: str | None = None, write_reports=True):
        assert not "architecture" in self._used_ports

        if build_dir is None:
            build_dir = self.build_dir
            assert build_dir is not None

        if not build_dir.endswith("/"):
            build_dir += "/"

        output_dir = f"{build_dir}/output"

        Path(build_dir).mkdir(parents=True, exist_ok=True)
        Path(output_dir).mkdir(parents=True, exist_ok=True)

        #
        # compile cohdl architecture
        #

        def architecture(inst):
            self._arch()

        entity_dict = {**self._used_ports, "architecture": architecture}

        self._top_entity = type(self._top_entity_name, (cohdl.Entity,), entity_dict)

        # print(cohdl.std.VhdlCompiler.to_string(self._top_entity))

        active_project = Project(self._top_entity_name, self.part_id, self.build_dir)
        set_active_project(active_project)

        file_list = cohdl.std.VhdlCompiler.to_dir(
            self._top_entity, active_project.paths.dir_generated_vhdl, mkdir=True
        )

        for vhdl_file in file_list:
            active_project.add_vhdl(vhdl_file)

        #
        # write constraints file
        #

        self._contraints.write_file(active_project.paths.project_constraints)
        active_project.add_constraints(active_project.paths.project_constraints)

        active_project.write()
